#!/bin/bash
# Restore script for {{ app_name }}
# Generated by Ansible - do not edit manually

set -e

# Configuration
APP_NAME="{{ app_name }}"
APP_USER="{{ app_user }}"
APP_DIR="/opt/${APP_NAME}"
BACKUP_DIR="${APP_DIR}/backup"
DOCUMENTS_DIR="${APP_DIR}/documents"
LOG_DIR="/var/log/${APP_NAME}"
RESTORE_LOG="${LOG_DIR}/restore.log"
DB_NAME="{{ db_name }}"
DB_USER="{{ db_user }}"
RESTORE_WORK_DIR="/tmp/${APP_NAME}_restore_$$"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "${RESTORE_LOG}"
}

error_exit() {
    log "ERROR: $1"
    cleanup
    exit 1
}

cleanup() {
    if [ -d "${RESTORE_WORK_DIR}" ]; then
        rm -rf "${RESTORE_WORK_DIR}"
    fi
}

validate_checksum() {
    local file="$1"
    local expected="$2"
    local actual

    actual=$(sha256sum "${file}" | cut -d' ' -f1)
    if [ "${actual}" != "${expected}" ]; then
        return 1
    fi
    return 0
}

usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] <backup_file.tar.gz>

Restore {{ app_name }} from backup archive.

OPTIONS:
    -f, --force     Skip confirmation prompt
    -d, --db-only   Restore database only (skip documents)
    -h, --help      Show this help message

EXAMPLES:
    $(basename "$0") ${BACKUP_DIR}/${APP_NAME}_20251126_020000.tar.gz
    $(basename "$0") --force /path/to/backup.tar.gz
    $(basename "$0") --db-only backup.tar.gz

EOF
    exit 0
}

# Parse arguments
FORCE=false
DB_ONLY=false
BACKUP_FILE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -f|--force)
            FORCE=true
            shift
            ;;
        -d|--db-only)
            DB_ONLY=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            BACKUP_FILE="$1"
            shift
            ;;
    esac
done

if [ -z "${BACKUP_FILE}" ]; then
    echo "Error: Backup file is required"
    echo ""
    usage
fi

if [ ! -f "${BACKUP_FILE}" ]; then
    error_exit "Backup file not found: ${BACKUP_FILE}"
fi

log "=========================================="
log "Starting restore from: ${BACKUP_FILE}"

# Confirmation prompt
if [ "${FORCE}" = "false" ]; then
    echo ""
    echo "WARNING: This will restore the database and documents from backup."
    echo "         All current data will be REPLACED."
    echo ""
    echo "Backup file: ${BACKUP_FILE}"
    echo ""
    read -p "Are you sure you want to continue? (yes/no): " confirm
    if [ "${confirm}" != "yes" ]; then
        echo "Restore cancelled."
        exit 0
    fi
fi

# Extract backup
log "Extracting backup archive..."
mkdir -p "${RESTORE_WORK_DIR}"
if ! tar -xzf "${BACKUP_FILE}" -C "${RESTORE_WORK_DIR}" 2>>"${RESTORE_LOG}"; then
    error_exit "Failed to extract backup archive"
fi

# Find the backup directory inside
BACKUP_NAME=$(ls "${RESTORE_WORK_DIR}")
BACKUP_CONTENT="${RESTORE_WORK_DIR}/${BACKUP_NAME}"

if [ ! -d "${BACKUP_CONTENT}" ]; then
    error_exit "Invalid backup structure"
fi

# Validate manifest
if [ ! -f "${BACKUP_CONTENT}/manifest.json" ]; then
    error_exit "Manifest file not found in backup"
fi

log "Reading manifest..."
# Extract checksums from manifest using grep/sed (portable)
DB_CHECKSUM=$(grep -o '"checksum_sha256": "[^"]*"' "${BACKUP_CONTENT}/manifest.json" | head -1 | sed 's/.*: "\([^"]*\)"/\1/')

# Validate database backup
if [ ! -f "${BACKUP_CONTENT}/database.sql" ]; then
    error_exit "Database backup file not found"
fi

log "Validating database backup checksum..."
if ! validate_checksum "${BACKUP_CONTENT}/database.sql" "${DB_CHECKSUM}"; then
    error_exit "Database backup checksum validation failed"
fi
log "Database backup checksum OK"

# Validate documents backup (if exists)
if [ -f "${BACKUP_CONTENT}/documents.tar.gz" ] && [ "${DB_ONLY}" = "false" ]; then
    DOCS_CHECKSUM=$(grep -o '"checksum_sha256": "[^"]*"' "${BACKUP_CONTENT}/manifest.json" | tail -1 | sed 's/.*: "\([^"]*\)"/\1/')
    if [ -n "${DOCS_CHECKSUM}" ] && [ "${DOCS_CHECKSUM}" != "null" ]; then
        log "Validating documents backup checksum..."
        if ! validate_checksum "${BACKUP_CONTENT}/documents.tar.gz" "${DOCS_CHECKSUM}"; then
            error_exit "Documents backup checksum validation failed"
        fi
        log "Documents backup checksum OK"
    fi
fi

# Stop application
log "Stopping application..."
if systemctl is-active --quiet "${APP_NAME}"; then
    sudo systemctl stop "${APP_NAME}"
    log "Application stopped"
else
    log "Application was not running"
fi

# Restore database
log "Restoring database..."
log "Dropping existing database connections..."
sudo -u postgres psql -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '${DB_NAME}' AND pid <> pg_backend_pid();" 2>>"${RESTORE_LOG}" || true

log "Dropping and recreating database..."
sudo -u postgres psql -c "DROP DATABASE IF EXISTS ${DB_NAME};" 2>>"${RESTORE_LOG}"
sudo -u postgres psql -c "CREATE DATABASE ${DB_NAME} OWNER ${DB_USER};" 2>>"${RESTORE_LOG}"

log "Importing database backup..."
if ! sudo -u postgres psql -d "${DB_NAME}" < "${BACKUP_CONTENT}/database.sql" >>"${RESTORE_LOG}" 2>&1; then
    error_exit "Database restore failed"
fi
log "Database restored successfully"

# Restore documents (if exists and not db-only)
if [ -f "${BACKUP_CONTENT}/documents.tar.gz" ] && [ "${DB_ONLY}" = "false" ]; then
    log "Restoring documents..."

    # Backup current documents (safety)
    if [ -d "${DOCUMENTS_DIR}" ] && [ "$(ls -A ${DOCUMENTS_DIR} 2>/dev/null)" ]; then
        DOCS_BACKUP="${DOCUMENTS_DIR}_pre_restore_$(date +%Y%m%d_%H%M%S)"
        log "Backing up current documents to: ${DOCS_BACKUP}"
        mv "${DOCUMENTS_DIR}" "${DOCS_BACKUP}"
    fi

    # Create fresh documents directory
    mkdir -p "${DOCUMENTS_DIR}"

    # Extract documents
    if ! tar -xzf "${BACKUP_CONTENT}/documents.tar.gz" -C "${APP_DIR}" 2>>"${RESTORE_LOG}"; then
        error_exit "Documents restore failed"
    fi

    # Fix ownership
    chown -R "${APP_USER}:${APP_USER}" "${DOCUMENTS_DIR}"

    log "Documents restored successfully"
else
    if [ "${DB_ONLY}" = "true" ]; then
        log "Skipping documents restore (--db-only specified)"
    else
        log "No documents to restore"
    fi
fi

# Cleanup
cleanup

# Start application
log "Starting application..."
sudo systemctl start "${APP_NAME}"

# Wait for application to start
log "Waiting for application to start..."
sleep 10

if systemctl is-active --quiet "${APP_NAME}"; then
    log "Application started successfully"
else
    log "WARNING: Application may not have started correctly. Check: sudo systemctl status ${APP_NAME}"
fi

log "=========================================="
log "Restore completed successfully"
log "Backup: ${BACKUP_FILE}"
log "=========================================="
