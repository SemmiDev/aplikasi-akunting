#!/bin/bash
# Backup script for {{ app_name }}
# Generated by Ansible - do not edit manually

set -e

# Configuration
APP_NAME="{{ app_name }}"
APP_USER="{{ app_user }}"
APP_DIR="/opt/${APP_NAME}"
BACKUP_DIR="${APP_DIR}/backup"
DOCUMENTS_DIR="${APP_DIR}/documents"
LOG_DIR="/var/log/${APP_NAME}"
BACKUP_LOG="${LOG_DIR}/backup.log"
DB_NAME="{{ db_name }}"
DB_USER="{{ db_user }}"
RETENTION_COUNT={{ backup_retention_count | default(7) }}
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_NAME="${APP_NAME}_${TIMESTAMP}"
BACKUP_WORK_DIR="${BACKUP_DIR}/${BACKUP_NAME}"

# Remote backup configuration (optional)
{% if backup_remote_enabled | default(false) %}
REMOTE_ENABLED=true
REMOTE_USER="{{ backup_remote_user }}"
REMOTE_HOST="{{ backup_remote_host }}"
REMOTE_PATH="{{ backup_remote_path }}"
{% else %}
REMOTE_ENABLED=false
{% endif %}

# Notification configuration (optional)
{% if backup_notification_enabled | default(false) %}
NOTIFICATION_ENABLED=true
NOTIFICATION_URL="{{ backup_notification_url }}"
{% else %}
NOTIFICATION_ENABLED=false
{% endif %}

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "${BACKUP_LOG}"
}

error_exit() {
    log "ERROR: $1"
    send_notification "FAILED" "$1"
    exit 1
}

send_notification() {
    local status="$1"
    local message="$2"

    if [ "${NOTIFICATION_ENABLED}" = "true" ]; then
        curl -s -X POST "${NOTIFICATION_URL}" \
            -H "Content-Type: application/json" \
            -d "{\"status\": \"${status}\", \"app\": \"${APP_NAME}\", \"message\": \"${message}\", \"timestamp\": \"${TIMESTAMP}\"}" \
            || log "WARNING: Failed to send notification"
    fi
}

calculate_checksum() {
    local file="$1"
    sha256sum "${file}" | cut -d' ' -f1
}

log "Starting backup: ${BACKUP_NAME}"

# Create backup working directory
mkdir -p "${BACKUP_WORK_DIR}"

# Database backup
log "Backing up database..."
if ! pg_dump -U "${DB_USER}" "${DB_NAME}" > "${BACKUP_WORK_DIR}/database.sql" 2>>"${BACKUP_LOG}"; then
    error_exit "Database backup failed"
fi
log "Database backup completed: $(stat -c%s "${BACKUP_WORK_DIR}/database.sql" 2>/dev/null || stat -f%z "${BACKUP_WORK_DIR}/database.sql") bytes"

# Documents backup (if directory exists and has content)
if [ -d "${DOCUMENTS_DIR}" ] && [ "$(ls -A ${DOCUMENTS_DIR} 2>/dev/null)" ]; then
    log "Backing up documents..."
    if ! tar -czf "${BACKUP_WORK_DIR}/documents.tar.gz" -C "${APP_DIR}" documents/ 2>>"${BACKUP_LOG}"; then
        error_exit "Documents backup failed"
    fi
    log "Documents backup completed: $(stat -c%s "${BACKUP_WORK_DIR}/documents.tar.gz" 2>/dev/null || stat -f%z "${BACKUP_WORK_DIR}/documents.tar.gz") bytes"
else
    log "No documents to backup (directory empty or does not exist)"
fi

# Create manifest
log "Creating manifest..."
DB_CHECKSUM=$(calculate_checksum "${BACKUP_WORK_DIR}/database.sql")

if [ -f "${BACKUP_WORK_DIR}/documents.tar.gz" ]; then
    DOCS_CHECKSUM=$(calculate_checksum "${BACKUP_WORK_DIR}/documents.tar.gz")
    DOCS_SIZE=$(stat -c%s "${BACKUP_WORK_DIR}/documents.tar.gz" 2>/dev/null || stat -f%z "${BACKUP_WORK_DIR}/documents.tar.gz")
else
    DOCS_CHECKSUM="null"
    DOCS_SIZE="0"
fi

cat > "${BACKUP_WORK_DIR}/manifest.json" << EOF
{
    "app_name": "${APP_NAME}",
    "timestamp": "${TIMESTAMP}",
    "created_at": "$(date -Iseconds)",
    "files": {
        "database": {
            "filename": "database.sql",
            "checksum_sha256": "${DB_CHECKSUM}",
            "size_bytes": $(stat -c%s "${BACKUP_WORK_DIR}/database.sql" 2>/dev/null || stat -f%z "${BACKUP_WORK_DIR}/database.sql")
        },
        "documents": {
            "filename": "documents.tar.gz",
            "checksum_sha256": ${DOCS_CHECKSUM:+\"$DOCS_CHECKSUM\"}${DOCS_CHECKSUM:-null},
            "size_bytes": ${DOCS_SIZE}
        }
    },
    "db_name": "${DB_NAME}",
    "db_user": "${DB_USER}"
}
EOF

# Create final archive
log "Creating final archive..."
if ! tar -czf "${BACKUP_DIR}/${BACKUP_NAME}.tar.gz" -C "${BACKUP_DIR}" "${BACKUP_NAME}" 2>>"${BACKUP_LOG}"; then
    error_exit "Final archive creation failed"
fi

# Cleanup working directory
rm -rf "${BACKUP_WORK_DIR}"

FINAL_SIZE=$(stat -c%s "${BACKUP_DIR}/${BACKUP_NAME}.tar.gz" 2>/dev/null || stat -f%z "${BACKUP_DIR}/${BACKUP_NAME}.tar.gz")
log "Final archive created: ${BACKUP_DIR}/${BACKUP_NAME}.tar.gz (${FINAL_SIZE} bytes)"

# Rotate old backups
log "Rotating old backups (keeping ${RETENTION_COUNT})..."
BACKUP_COUNT=$(ls -1 "${BACKUP_DIR}"/*.tar.gz 2>/dev/null | wc -l)
if [ "${BACKUP_COUNT}" -gt "${RETENTION_COUNT}" ]; then
    DELETE_COUNT=$((BACKUP_COUNT - RETENTION_COUNT))
    ls -1t "${BACKUP_DIR}"/*.tar.gz | tail -n "${DELETE_COUNT}" | while read -r old_backup; do
        log "Deleting old backup: ${old_backup}"
        rm -f "${old_backup}"
    done
fi

# Sync to remote (if configured)
if [ "${REMOTE_ENABLED}" = "true" ]; then
    log "Syncing to remote: ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_PATH}"
    if ! rsync -avz "${BACKUP_DIR}/${BACKUP_NAME}.tar.gz" "${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_PATH}/" 2>>"${BACKUP_LOG}"; then
        log "WARNING: Remote sync failed (backup still available locally)"
    else
        log "Remote sync completed"
    fi
fi

log "Backup completed successfully: ${BACKUP_NAME}"
send_notification "SUCCESS" "Backup completed: ${BACKUP_NAME}.tar.gz (${FINAL_SIZE} bytes)"

echo "${BACKUP_DIR}/${BACKUP_NAME}.tar.gz"
